import os
import asyncio
import json
import random
import time
import requests
from decimal import Decimal, getcontext
from dotenv import load_dotenv
from eth_account import Account
from web3 import Web3
from web3.middleware import ExtraDataToPOAMiddleware
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes
from google import genai # <--- Required for AI Sentinel

# --- 1. SETUP & AUTH ---
getcontext().prec = 28
load_dotenv()

# Initialize Gemini AI
ai_client = genai.Client(api_key=os.getenv("GEMINI_API_KEY"))

util_w3 = Web3()

def get_w3():
    """Robust RPC connection logic for Wallet fetching."""
    urls = [
        os.getenv("RPC_URL", "https://polygon-rpc.com"), 
        "https://rpc.ankr.com/polygon",
        "https://1rpc.io/matic"
    ]
    for url in urls:
        if not url: continue
        try:
            _w3 = Web3(Web3.HTTPProvider(url, request_kwargs={'timeout': 10}))
            if _w3.is_connected():
                _w3.middleware_onion.inject(ExtraDataToPOAMiddleware, layer=0)
                return _w3
        except: continue
    return None

w3 = get_w3()
active_w3 = w3 if w3 else util_w3
Account.enable_unaudited_hdwallet_features()

def get_vault():
    """Generates the secure Vault object from the Seed/Private Key."""
    seed = os.getenv("WALLET_SEED")
    if not seed: return None
    try:
        if len(seed) == 64 or seed.startswith("0x"): return Account.from_key(seed)
        return Account.from_mnemonic(seed)
    except: return None

vault = get_vault()
auto_mode_enabled = False

# Native USDC on Polygon for Balance Checking
USDC_NATIVE = active_w3.to_checksum_address("0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359")
ERC20_ABI = json.loads('[{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"type":"function"}]')
usdc_contract = active_w3.eth.contract(address=USDC_NATIVE, abi=ERC20_ABI)

async def fetch_balances(address):
    if not active_w3 or not active_w3.is_connected(): return Decimal('0'), Decimal('0')
    try:
        raw_pol = await asyncio.to_thread(active_w3.eth.get_balance, address)
        raw_usdc = await asyncio.to_thread(usdc_contract.functions.balanceOf(address).call)
        return active_w3.from_wei(raw_pol, 'ether'), Decimal(raw_usdc) / Decimal(10**6)
    except: return Decimal('0'), Decimal('0')

# --- 2. OFFICIAL POLYMARKET CLOB SDK (AUTO-DERIVATION) ---
try:
    from py_clob_client.client import ClobClient
    from py_clob_client.clob_types import MarketOrderArgs, OrderType
    from py_clob_client.order_builder.constants import BUY
except ImportError:
    print("CRITICAL ERROR: py-clob-client is not installed. Run 'pip install py-clob-client'")
    exit(1)

clob_client = None

if vault:
    # Auto-derive credentials directly from Vault
    derived_private_key = vault.key.hex() if isinstance(vault.key, bytes) else vault.key
    if not derived_private_key.startswith("0x"): derived_private_key = "0x" + derived_private_key
    derived_funder = vault.address
    
    print(f"üöÄ Booting Vault Signature for: {derived_funder}")
    
    try:
        clob_client = ClobClient(host="https://clob.polymarket.com", key=derived_private_key, chain_id=137, signature_type=0, funder=derived_funder)
        clob_client.set_api_creds(clob_client.create_or_derive_api_creds())
        print("‚úÖ CLOB API Authenticated Successfully")
    except Exception as e:
        print(f"‚ùå CLOB API Auth Failed: {e}")
else:
    print("‚ùå CRITICAL: Could not load Vault. Check WALLET_SEED in .env")

# --- 3. DYNAMIC MARKET SEARCH MAPPING ---
POOLS = {
    "BTC":   {"keyword": "Bitcoin price", "price": "üü†"},
    "ETH":   {"keyword": "Ethereum price", "price": "üîµ"},
    "SOL":   {"keyword": "Solana price", "price": "üü£"},
    "MATIC": {"keyword": "Polygon price", "price": "üîò"},
    "BVIV":  {"keyword": "Bitcoin Volatility", "price": "üìä"},
    "EVIV":  {"keyword": "Ethereum Volatility", "price": "üìà"}
}

# --- 4. AI GATEKEEPER & DYNAMIC SEARCH ---
async def validate_with_ai(question, description, asset):
    """Gemini 2.0 validates if the market is short-term and correct."""
    prompt = f"Analyze this Polymarket bet: Q: {question} Rules: {description} Target: {asset}. Does this resolve in <24h and track {asset} price? Respond ONLY 'YES' or a 1-sentence 'NO' reason."
    try:
        response = await asyncio.to_thread(ai_client.models.generate_content, model="gemini-2.0-flash", contents=prompt)
        return response.text.strip().upper()
    except: return "YES" # Fallback to YES if AI is rate-limited

async def get_validated_token_id(keyword, side, asset_name):
    url = f"https://gamma-api.polymarket.com/events?q={keyword}&active=true&closed=false"
    try:
        resp = requests.get(url, timeout=10).json()
        for event in resp:
            # AI Validation Step
            ai_decision = await validate_with_ai(event.get("title", ""), event.get("description", ""), asset_name)
            if "YES" in ai_decision:
                markets = event.get("markets", [])
                for m in markets:
                    ids = m.get("clobTokenIds", [])
                    if len(ids) == 2:
                        return (ids[0] if side == "UP" else ids[1]), m.get("question")
    except: pass
    return None, None

# --- 5. THE SIMULTANEOUS PROFIT-SNIPER ENGINE ---
async def run_api_execution(context, chat_id, side, asset_override=None):
    if not clob_client:
        return await context.bot.send_message(chat_id, "‚ùå Error: CLOB Client offline.")

    pool_key = asset_override or context.user_data.get('pair', 'BTC')
    stake = float(context.user_data.get('stake', 50))
    
    msg = await context.bot.send_message(chat_id, f"üõ∞Ô∏è **AI Sentinel scanning {pool_key} markets...**")
    
    token_id, market_name = await get_validated_token_id(POOLS[pool_key]["keyword"], side, pool_key)
    
    if not token_id:
        return await context.bot.edit_message_text(f"‚ùå **REJECTED:** No valid markets found.", chat_id=chat_id, message_id=msg.message_id)

    await context.bot.edit_message_text(f"üéØ **AI APPROVED:** `{market_name}`\nConcurrent Sim & Prep Initiated...", chat_id=chat_id, message_id=msg.message_id)

    try:
        # STEP 1: PARALLEL EXECUTION
        mo_args = MarketOrderArgs(token_id=token_id, amount=stake, side=BUY)
        sim_task = asyncio.to_thread(clob_client.get_midpoint, token_id)
        prep_task = asyncio.to_thread(clob_client.create_market_order, mo_args)
        
        mid_price_str, signed_order = await asyncio.gather(sim_task, prep_task)
        current_price = float(mid_price_str)
        
        if current_price > 0.90:
            return await context.bot.edit_message_text(f"‚ùå **PRICE GUARD:** Mid-price too high (${current_price:.2f}).", chat_id=chat_id, message_id=msg.message_id)
            
        # STEP 2: EXACT 1ms PHYSICAL DELAY 
        start_time = time.perf_counter()
        while (time.perf_counter() - start_time) < 0.0010: pass 

        # STEP 3: ATOMIC EXECUTION (Fill-Or-Kill)
        resp = await asyncio.to_thread(clob_client.post_order, signed_order, OrderType.FOK)
        
        if resp and resp.get("success"):
            net_profit = (stake / current_price) - stake
            report = (f"‚úÖ **WINNING HIT CONFIRMED**\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüéØ Target: `{market_name}`\n"
                      f"üí∞ **Net Profit: +${net_profit:.2f}**\n‚ö° Timing: 1ms Offset\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
            await context.bot.edit_message_text(report, chat_id=chat_id, message_id=msg.message_id, parse_mode='Markdown')
        else:
            await context.bot.edit_message_text(f"‚ùå **REJECTED:** {resp.get('errorMsg', 'Liquidity error')}", chat_id=chat_id, message_id=msg.message_id)

    except Exception as e:
        await context.bot.edit_message_text(f"‚ùå **SYSTEM ERROR:** `{str(e)}`", chat_id=chat_id, message_id=msg.message_id)

# --- 6. UI HANDLERS ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    pol, usdc = await fetch_balances(vault.address) if vault else (0, 0)
    keyboard = [['üöÄ Start Trading', '‚öôÔ∏è Settings'], ['üí∞ Wallet', 'ü§ñ AUTO MODE']]
    welcome = (f"üï¥Ô∏è **APEX v45.0 AI-Sentinel**\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
               f"‚õΩ POL: `{pol:.4f}`\nüíµ USDC: `${usdc:.2f}`\n"
               f"üìç Sync: `AI-Validation -> 1ms Sniper`")
    await update.message.reply_text(welcome, reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True))

async def main_chat_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global auto_mode_enabled
    text, chat_id = update.message.text, update.message.chat_id
    if text == 'üöÄ Start Trading':
        kb = [[InlineKeyboardButton(f"{k} {POOLS[k]['price']}", callback_data=f"PAIR_{k}") for k in list(POOLS.keys())[:3]],
              [InlineKeyboardButton(f"{k} {POOLS[k]['price']}", callback_data=f"PAIR_{k}") for k in list(POOLS.keys())[3:]]]
        await update.message.reply_text("üéØ **SELECT NATIVE CLOB POOL:**", reply_markup=InlineKeyboardMarkup(kb))
    elif text == '‚öôÔ∏è Settings':
        kb = [[InlineKeyboardButton(f"${x}", callback_data=f"SET_{x}") for x in [10, 50, 100]],
              [InlineKeyboardButton(f"${x}", callback_data=f"SET_{x}") for x in [500, 1000]]]
        await update.message.reply_text("‚öôÔ∏è **Configure Stake Amount:**", reply_markup=InlineKeyboardMarkup(kb))
    elif text == 'üí∞ Wallet':
        pol, usdc = await fetch_balances(vault.address) if vault else (0, 0)
        await update.message.reply_text(f"üí≥ **Vault Status**\n‚õΩ POL: `{pol:.6f}`\nüíµ USDC: `${usdc:.2f}`\nüìç `{vault.address}`")
    elif text == 'ü§ñ AUTO MODE':
        auto_mode_enabled = not auto_mode_enabled
        if auto_mode_enabled: asyncio.create_task(autopilot_loop(chat_id, context))
        await update.message.reply_text(f"ü§ñ **Auto Pilot {'ACTIVATED ‚úÖ' if auto_mode_enabled else 'STOPPED üõë'}**")

async def handle_interaction(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    if query.data.startswith("SET_"):
        context.user_data['stake'] = int(query.data.split("_")[1])
        await query.edit_message_text(f"‚úÖ Stake set to **${context.user_data['stake']}**")
    elif query.data.startswith("PAIR_"):
        context.user_data['pair'] = query.data.split("_")[1]
        kb = [[InlineKeyboardButton("CALL üìà", callback_data="EXEC_UP"), InlineKeyboardButton("PUT üìâ", callback_data="EXEC_DOWN")]]
        await query.edit_message_text(f"üíé Pool: **{context.user_data['pair']}**\nChoose Direction:", reply_markup=InlineKeyboardMarkup(kb))
    elif query.data.startswith("EXEC_"):
        await run_api_execution(context, query.message.chat_id, "UP" if "UP" in query.data else "DOWN")

async def autopilot_loop(chat_id, context):
    while auto_mode_enabled:
        target = random.choice(list(POOLS.keys()))
        await run_api_execution(context, chat_id, random.choice(["UP", "DOWN"]), asset_override=target)
        await asyncio.sleep(random.randint(60, 120))

if __name__ == "__main__":
    TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
    if TOKEN:
        app = ApplicationBuilder().token(TOKEN).build()
        app.add_handler(CommandHandler("start", start))
        app.add_handler(CallbackQueryHandler(handle_interaction))
        app.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), main_chat_handler))
        app.run_polling(drop_pending_updates=True)

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































