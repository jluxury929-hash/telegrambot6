import os
import asyncio
import json
import time
import requests
from decimal import Decimal, getcontext
from dotenv import load_dotenv
from eth_account import Account
from web3 import Web3
from web3.middleware import ExtraDataToPOAMiddleware
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes
from google import genai

# --- 1. CORE SETUP ---
getcontext().prec = 28
load_dotenv()
ai_client = genai.Client(api_key=os.getenv("GEMINI_API_KEY"))

def get_w3():
    rpc_list = [os.getenv("RPC_URL"), "https://polygon-rpc.com", "https://1rpc.io/matic"]
    for url in rpc_list:
        if not url: continue
        try:
            _w3 = Web3(Web3.HTTPProvider(url, request_kwargs={'timeout': 10}))
            if _w3.is_connected():
                _w3.middleware_onion.inject(ExtraDataToPOAMiddleware, layer=0)
                return _w3
        except: continue
    return None

w3 = get_w3()
Account.enable_unaudited_hdwallet_features()
vault = Account.from_key(os.getenv("WALLET_SEED")) if " " not in os.getenv("WALLET_SEED", "") else Account.from_mnemonic(os.getenv("WALLET_SEED"))

try:
    from py_clob_client.client import ClobClient
    from py_clob_client.clob_types import MarketOrderArgs, OrderType
    from py_clob_client.order_builder.constants import BUY
except:
    exit("Install: pip install py-clob-client google-genai requests")

clob_client = ClobClient(host="https://clob.polymarket.com", key=vault.key.hex(), chain_id=137, signature_type=0, funder=vault.address)
clob_client.set_api_creds(clob_client.create_or_derive_api_creds())

# --- 2. THE NEURAL HARVESTER (THE FIX) ---

async def harvest_winning_bets():
    """
    Brute-force scours the entire exchange. 
    Uses AI to select ONLY high-probability, high-profit crypto bets.
    """
    # 1. Grab every single active market from the CLOB (Direct Orderbook Access)
    try:
        raw_markets = await asyncio.to_thread(clob_client.get_markets)
        # Filter for Binary (Yes/No) and Active
        active_pool = [m for m in raw_markets if m.get('active') and len(m.get('clobTokenIds', [])) == 2]
    except:
        return []

    # 2. Batch AI Analysis (Neural Sieve)
    # We send the top 40 liquid markets to Gemini to find the "Gems"
    market_summaries = []
    for m in active_pool[:40]:
        market_summaries.append({
            "id": m['clobTokenIds'],
            "q": m['question'],
            "desc": m.get('description', '')
        })

    prompt = f"""
    Analyze these 40 Polymarket bets: {json.dumps(market_summaries)}
    
    1. Identify the 6 most PROBABLE to win based on current crypto trends (Feb 2026).
    2. Rank them by PROFITABILITY.
    3. For each, pick the side: 'UP' or 'DOWN'.
    
    Return ONLY a JSON list: [{{"title": "...", "side": "UP/DOWN", "confidence": "90%", "profit_rank": 1, "token_id": "..."}}]
    """
    
    try:
        response = await asyncio.to_thread(
            ai_client.models.generate_content, 
            model="gemini-1.5-flash", 
            contents=prompt,
            config={'response_mime_type': 'application/json'}
        )
        return json.loads(response.text)
    except:
        return []

# --- 3. ATOMIC STRIKE ENGINE ---

async def execute_atomic_strike(context, chat_id, bet):
    stake = float(context.user_data.get('stake', 50))
    token_id = bet['token_id']
    
    msg = await context.bot.send_message(chat_id, f"ðŸ“¡ **NEURAL STRIKE INITIATED: {bet['side']}...**")
    
    try:
        # Precision Prep
        mid = float(await asyncio.to_thread(clob_client.get_midpoint, token_id))
        order = await asyncio.to_thread(clob_client.create_market_order, MarketOrderArgs(token_id=token_id, amount=stake, side=BUY))
        
        # 1ms Hardware Lock
        s = time.perf_counter()
        while (time.perf_counter() - s) < 0.0010: pass
        
        resp = await asyncio.to_thread(clob_client.post_order, order, OrderType.FOK)
        
        if resp.get("success"):
            await context.bot.edit_message_text(f"âœ… **WIN CONFIRMED**\nðŸŽ¯ {bet['title']}\nðŸ“ˆ Price: ${mid:.3f}\nðŸ’ª Confidence: {bet['confidence']}", chat_id=chat_id, message_id=msg.message_id)
    except Exception as e:
        await context.bot.edit_message_text(f"â˜¢ï¸ **STRIKE ABORTED:** {e}", chat_id=chat_id, message_id=msg.message_id)

# --- 4. INTERFACE ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    kb = [['âš”ï¸ START ENGINE', 'âš™ï¸ CALIBRATE'], ['ðŸ’³ VAULT', 'ðŸ¤– AUTO-STRIKE']]
    await update.message.reply_text("ðŸ¦¾ **APEX v67.0: THE HARVESTER**\n`Neural Sieve: ACTIVE | 24/7 Global Scour`", reply_markup=ReplyKeyboardMarkup(kb, resize_keyboard=True))

async def main_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message.text == 'âš”ï¸ START ENGINE':
        status = await update.message.reply_text("ðŸ“¡ **AI SCOURING GLOBAL MARKETPLACE...**")
        winning_bets = await harvest_winning_bets()
        
        if not winning_bets:
            return await status.edit_text("âŒ Matrix Cold. Re-calibrating Neural Sieve...")

        kb = []
        for i, bet in enumerate(winning_bets):
            kb.append([InlineKeyboardButton(f"ðŸ’° #{bet['profit_rank']} {bet['title'][:25]}... | {bet['confidence']}", callback_data=f"STRIKE_{i}")])
        
        context.user_data['active_bets'] = winning_bets
        await status.edit_text("ðŸŽ¯ **AI-PICKED HIGH-PROBABILITY BETS:**", reply_markup=InlineKeyboardMarkup(kb))
    
    elif update.message.text == 'âš™ï¸ CALIBRATE':
        kb = [[InlineKeyboardButton(f"${x}", callback_data=f"SET_{x}") for x in [10, 50, 100, 500, 1000]]]
        await update.message.reply_text("âš™ï¸ **ADJUST LOAD:**", reply_markup=InlineKeyboardMarkup(kb))

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query; await query.answer()
    if "SET_" in query.data:
        context.user_data['stake'] = int(query.data.split("_")[1])
        await query.edit_message_text(f"âœ… **STAKE:** ${context.user_data['stake']}")
    elif "STRIKE_" in query.data:
        idx = int(query.data.split("_")[1])
        selected_bet = context.user_data['active_bets'][idx]
        await execute_atomic_strike(context, query.message.chat_id, selected_bet)

if __name__ == "__main__":
    t = os.getenv("TELEGRAM_BOT_TOKEN")
    if t:
        app = ApplicationBuilder().token(t).build()
        app.add_handler(CommandHandler("start", start))
        app.add_handler(CallbackQueryHandler(handle_callback))
        app.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), main_handler))
        app.run_polling()

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































