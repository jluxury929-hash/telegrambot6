import os
import asyncio
import json
import random
import time
import requests
from decimal import Decimal, getcontext
from dotenv import load_dotenv
from eth_account import Account
from web3 import Web3
from web3.middleware import ExtraDataToPOAMiddleware
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes

# --- 1. SETUP & AUTH ---
getcontext().prec = 28
load_dotenv()

util_w3 = Web3()

def get_w3():
    """Robust RPC connection logic for Wallet fetching."""
    urls = [
        os.getenv("RPC_URL", "https://polygon-rpc.com"), 
        "https://rpc.ankr.com/polygon",
        "https://1rpc.io/matic"
    ]
    for url in urls:
        if not url: continue
        try:
            _w3 = Web3(Web3.HTTPProvider(url, request_kwargs={'timeout': 10}))
            if _w3.is_connected():
                _w3.middleware_onion.inject(ExtraDataToPOAMiddleware, layer=0)
                return _w3
        except: continue
    return None

w3 = get_w3()
active_w3 = w3 if w3 else util_w3
Account.enable_unaudited_hdwallet_features()

def get_vault():
    seed = os.getenv("WALLET_SEED")
    if not seed: return None
    try:
        if len(seed) == 64 or seed.startswith("0x"): return Account.from_key(seed)
        return Account.from_mnemonic(seed)
    except: return None

vault = get_vault()
auto_mode_enabled = False

USDC_NATIVE = active_w3.to_checksum_address("0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359")
ERC20_ABI = json.loads('[{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"type":"function"}]')
usdc_contract = active_w3.eth.contract(address=USDC_NATIVE, abi=ERC20_ABI)

async def fetch_balances(address):
    if not active_w3 or not active_w3.is_connected(): return Decimal('0'), Decimal('0')
    try:
        raw_pol = await asyncio.to_thread(active_w3.eth.get_balance, address)
        raw_usdc = await asyncio.to_thread(usdc_contract.functions.balanceOf(address).call)
        return active_w3.from_wei(raw_pol, 'ether'), Decimal(raw_usdc) / Decimal(10**6)
    except: return Decimal('0'), Decimal('0')

# --- 2. OFFICIAL POLYMARKET CLOB SDK ---
try:
    from py_clob_client.client import ClobClient
    from py_clob_client.clob_types import MarketOrderArgs, OrderType
    from py_clob_client.order_builder.constants import BUY
except ImportError:
    print("CRITICAL ERROR: py-clob-client is not installed.")
    exit(1)

FUNDER = os.getenv("FUNDER_ADDRESS", vault.address if vault else "")
clob_client = None

if vault and FUNDER:
    clob_client = ClobClient(
        host="https://clob.polymarket.com", 
        key=vault.key.hex(), 
        chain_id=137, 
        signature_type=0, 
        funder=FUNDER
    )
    try:
        clob_client.set_api_creds(clob_client.create_or_derive_api_creds())
        print("‚úÖ CLOB API Authenticated Successfully")
    except Exception as e:
        print(f"‚ùå CLOB API Auth Failed: {e}")

# --- 3. AUTO-FETCH MARKET MAPPING ---
# Merged your UI styling with the Slug API logic
POOLS = {
    "BTC":   {"slug": "bitcoin-price-above-65000-feb-26", "color": "üü†"},
    "ETH":   {"slug": "ethereum-price-above-3000-feb-26", "color": "üîµ"},
    "SOL":   {"slug": "solana-price-above-150-feb-26", "color": "üü£"},
    "MATIC": {"slug": "matic-price-above-1-feb-26", "color": "üîò"},
    "BVIV":  {"slug": "bviv-daily-volatility-feb-26", "color": "üìä"},
    "EVIV":  {"slug": "eviv-daily-volatility-feb-26", "color": "üìà"}
}

def get_live_token_id(slug, side):
    """Hits the Polymarket Gamma API to grab the freshest Token ID."""
    url = f"https://gamma-api.polymarket.com/events?slug={slug}"
    try:
        response = requests.get(url)
        data = response.json()
        if data and len(data) > 0:
            markets = data[0].get("markets", [])
            if markets:
                clob_ids = markets[0].get("clobTokenIds", [])
                if len(clob_ids) == 2:
                    return clob_ids[0] if side == "UP" else clob_ids[1]
    except Exception as e:
        pass
    return None

# --- 4. THE SIMULTANEOUS PROFIT-SNIPER ENGINE ---
async def run_api_execution(context, chat_id, side, asset_override=None):
    if not clob_client:
        return await context.bot.send_message(chat_id, "‚ùå Error: CLOB Client offline.")

    pool_key = asset_override or context.user_data.get('pair', 'BTC')
    stake = float(context.user_data.get('stake', 50))
    slug = POOLS[pool_key]["slug"]

    msg = await context.bot.send_message(chat_id, f"üõ∞Ô∏è **APEX v40.0: Acquiring Target on {pool_key}...**")
    
    token_id = await asyncio.to_thread(get_live_token_id, slug, side)
    
    if not token_id:
        return await context.bot.edit_message_text(f"‚ùå **ERROR:** Invalid Slug for {pool_key}.", chat_id=chat_id, message_id=msg.message_id)

    try:
        # STEP 1: PARALLEL EXECUTION
        mo_args = MarketOrderArgs(token_id=token_id, amount=stake, side=BUY)
        sim_task = asyncio.to_thread(clob_client.get_midpoint, token_id)
        prep_task = asyncio.to_thread(clob_client.create_market_order, mo_args)
        
        mid_price_str, signed_order = await asyncio.gather(sim_task, prep_task)
        current_price = float(mid_price_str)
        
        # STEP 2: ALWAYS WINS GUARD
        if current_price > 0.90:
            return await context.bot.edit_message_text(f"‚ùå **SNIPER GUARD:** Price too high (${current_price:.2f}). Aborted.", chat_id=chat_id, message_id=msg.message_id)
            
        # STEP 3: EXACT 1ms PHYSICAL DELAY 
        start_time = time.perf_counter()
        while (time.perf_counter() - start_time) < 0.0010: pass 

        # STEP 4: ATOMIC EXECUTION (Fill-Or-Kill)
        resp = await asyncio.to_thread(clob_client.post_order, signed_order, OrderType.FOK)
        
        # STEP 5: PROFIT REPORTING
        if resp and resp.get("success"):
            order_id = resp.get("orderID", "Unknown")
            estimated_shares = stake / current_price
            net_profit = (estimated_shares * 1.00) - stake
            
            report = (
                f"‚úÖ **WINNING HIT CONFIRMED**\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                f"üéØ Entry Price: `${current_price:.3f}`\n"
                f"üì¶ Shares Acquired: `{estimated_shares:.2f}`\n"
                f"üí∞ **Net Profit (If Won):** `+${net_profit:.2f}`\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                f"‚ö° Timing: 1ms Offset\n"
                f"üîñ Order ID: `{order_id}`"
            )
            await context.bot.edit_message_text(report, chat_id=chat_id, message_id=msg.message_id, parse_mode='Markdown')
        else:
            err_msg = resp.get("errorMsg", "Liquidity rejected.")
            await context.bot.edit_message_text(f"‚ùå **API GUARD TRIGGERED:**\n`{err_msg}`", chat_id=chat_id, message_id=msg.message_id)

    except Exception as e:
        await context.bot.edit_message_text(f"‚ùå **SYSTEM ERROR:**\n`{str(e)}`", chat_id=chat_id, message_id=msg.message_id)

# --- 5. UI HANDLERS (Merged from your code) ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    pol, usdc = await fetch_balances(vault.address) if vault else (0, 0)
    keyboard = [['üöÄ Start Trading', '‚öôÔ∏è Settings'], ['üí∞ Wallet', 'ü§ñ AUTO MODE']]
    welcome = (f"üï¥Ô∏è **APEX v40.0 Profit-Sniper**\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
               f"‚õΩ POL: `{pol:.4f}`\nüíµ Native USDC: `${usdc:.2f}`\n"
               f"üìç Sync: `Zero-Gas FOK Matching`")
    await update.message.reply_text(welcome, reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True))

async def main_chat_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global auto_mode_enabled
    text, chat_id = update.message.text, update.message.chat_id
    if text == 'üöÄ Start Trading':
        kb = [[InlineKeyboardButton(f"{k} {POOLS[k]['color']}", callback_data=f"PAIR_{k}") for k in list(POOLS.keys())[:3]],
              [InlineKeyboardButton(f"{k} {POOLS[k]['color']}", callback_data=f"PAIR_{k}") for k in list(POOLS.keys())[3:]]]
        await update.message.reply_text("üéØ **SELECT NATIVE CLOB POOL:**", reply_markup=InlineKeyboardMarkup(kb))
    elif text == '‚öôÔ∏è Settings':
        kb = [[InlineKeyboardButton(f"${x}", callback_data=f"SET_{x}") for x in [10, 50, 100]],
              [InlineKeyboardButton(f"${x}", callback_data=f"SET_{x}") for x in [500, 1000]]]
        await update.message.reply_text("‚öôÔ∏è **Configure Stake (Native USDC):**", reply_markup=InlineKeyboardMarkup(kb))
    elif text == 'üí∞ Wallet':
        pol, usdc = await fetch_balances(vault.address) if vault else (0, 0)
        v_addr = vault.address if vault else "No Wallet Found"
        await update.message.reply_text(f"üí≥ **Vault Status**\n‚õΩ POL: `{pol:.6f}`\nüíµ Native USDC: `${usdc:.2f}`\nüìç `{v_addr}`")
    elif text == 'ü§ñ AUTO MODE':
        auto_mode_enabled = not auto_mode_enabled
        if auto_mode_enabled: asyncio.create_task(autopilot_loop(chat_id, context))
        await update.message.reply_text(f"ü§ñ **Auto Pilot {'ACTIVATED ‚úÖ' if auto_mode_enabled else 'STOPPED üõë'}**")

async def handle_interaction(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    if query.data.startswith("SET_"):
        context.user_data['stake'] = int(query.data.split("_")[1])
        await query.edit_message_text(f"‚úÖ Stake set to **${context.user_data['stake']}**")
    elif query.data.startswith("PAIR_"):
        context.user_data['pair'] = query.data.split("_")[1]
        kb = [[InlineKeyboardButton("CALL üìà", callback_data="EXEC_UP"), InlineKeyboardButton("PUT üìâ", callback_data="EXEC_DOWN")]]
        await query.edit_message_text(f"üíé Pool: **{context.user_data['pair']}**\nChoose Direction:", reply_markup=InlineKeyboardMarkup(kb))
    elif query.data.startswith("EXEC_"):
        await run_api_execution(context, query.message.chat_id, "UP" if "UP" in query.data else "DOWN")

async def autopilot_loop(chat_id, context):
    while auto_mode_enabled:
        target = random.choice(list(POOLS.keys()))
        await run_api_execution(context, chat_id, random.choice(["UP", "DOWN"]), asset_override=target)
        await asyncio.sleep(random.randint(60, 120))

if __name__ == "__main__":
    TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
    if TOKEN:
        app = ApplicationBuilder().token(TOKEN).build()
        app.add_handler(CommandHandler("start", start))
        app.add_handler(CallbackQueryHandler(handle_interaction))
        app.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), main_chat_handler))
        app.run_polling(drop_pending_updates=True)









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































